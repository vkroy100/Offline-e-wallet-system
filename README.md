# Offline-e-wallet-system
We have some places still lacking internet connectivity. In such places it becomes extremely difficult to
use or even initialize the use of electronic payment methods. Now to address this issue I have
developed an application which is analogous to a stored value card . This uses wifi direct to provide
safe and secure payment solutions. Main aim is to reduce the need of internet connectivity for each and
every transaction. The balance is stored locally on mobile phones rather than on a server. The user can
add balance (money) to their app in exchange of physical money and can get physical money in return
of their available balance. We have used wifi direct because it allows two devices to establish a direct
Wi-Fi connection without requiring a wireless router.
The application has following components : First of all is User Registration : One has to register once
to create their identity and certificate that is to be used by the app. User registration generates a random
keypair for RSA (2048 bits) and a certificate signing request (CSR). This CSR is sent to a CA server for
the app, deployed to sign the request and send it back to the user. The signed certificate helps in
establishing the identity and authentication. This one time registration requires network connectivity.
We have used Trust store to safely store the certificates of CA and a key store is used to store all the
other types of certificates , private keys and password safely.
So at a time we have two devices which will communicate with each other , one of them will be a
server thread and this server thread will instantiate a socket and bind it, this thread all create a
sendreceive thread . Similarly we have other device which is client and client thread is created in this
which will connect to the server socket and address of which is taken from wifi- connection info. Client thread will also start a sendreceive thread. This send receive thread started by both client and server is
used for sending and receiving the data objects.
Now the two usersâ€™ app communicating will authenticate each other that whether they are having valid
certificates or not. Now both the users will send their certificates to each other , both verify each other
certificates if verified then each of them extracts public key from the respective certificates. Now each
of the user generates a challenge and random key and encrypt these with the public key of their counter
part, after encrypting each user send it to each other. Now using their respective private keys, the users
decrypt the challenge and response, now each user has two random keys , one that is generated by own
and other which he got from the other end, the shared session key is generated by taking the xor of the
both random keys, the each user solves the challenge and encrypt the result with the shared session key
and sent it to other end, now the user at the other end will decrypt it with the session key and verify if
the result of challenge is matching or not. If it matches at both the end then the authentication is
complete and then they will transfer amount. Error at any step leads to failure in authentication and the
connection is terminated.
Messages after mutual authentication follows a tagged format. The first byte of the data object gives the
information about the type of message, the rest of the bytes are the value of the message.
For example: Suppose <3,50> is a data object, the first byte is 3 which means that the rest of the bytes
are the amount. This data object is then encrypted (using AES) and sent to the other side and if all goes
well then decrypted data object will be <3,50> and will indicate that this data object contains the
amount. Similarly, the receiver sends acknowledgement about the money received as <1,transaction
record> and the payer will store the value of this data object as transaction history.
Each transacion record has the following structure:
1. TransactionID - Hash of (2),(3),(4) & (5)
2. Identifier of own device
3. Identifier of other device
4. Amount
5. Timestamp provided by the receiver
6. Digital Signature of receiver 

The digital money is stored as an integer in SharedPreferences, a safe and secure mechanism provided
by Android OS to app developers. SharedPreferences of one app can not be accessed by other apps and
users. SharedPreferences reside at a location which is private and accessible by the owning app.
Transaction related information (shared between the payer and the receiver i.e.
userId,transactionId,amount,timestamp) are saved on both sides locally in SQLite database.
